# GLTF TO ECS IS PAIN

There is a dilema on who gets entity id node or primitive ,after some painful 
hours of though and research i have come to the conclusion to make two types of Renderable Component sacrificing some cache coherence.
Its the mainatainable way i could come up with as hierarchy is a pain in ecs , so with this method.

So design is Node gets entity Id , primitives are treated depending on how many primitives a 
node (mesh , assuming node only references one mesh) has , if its one then its a simple RenderableComponent ,
and if its two or more its a FATRenderableComponent.The FATRenderableComponent is a component that contains a vector containing Renderable components.


Now for Rendering system to not lose cache advantage of ecs i propose using a two step method of preparing rendering data ,

1) Get all entity that contains RenderableComponent and TransformComponent.
2) Get all entites with FATRenderableComponent and TransformComponent.

This two step process hopes to provide atleast some coherency,but 
might not be enough casue a model might most have FATRenderableComponent more.


I am hoping any other system can atleast make use of ecs fully.

Struct HierarchyComponent
{
std::vector<EntityId> children;
};

struct RenderableComponent
{
 
}

struct FATRenderableComponent
{
std::vector<RenderableComponent> renderableComponent;
}





# Using Intermediatery Engine Data structures 

I have decided to use intermediatory engine data structures to decouple loading of model/scene data from core engine infrastructure , 
an intermediatery format that is consumable by engine data uploaders like ecs , texture , material systems, vertex buffer systems.

This will be more maintainable and can help me support other file formats also cause now i 
have a target format to which other formats needs to be converted and this intermediatory format is 
consumable by engine so only need to write convertors and no need to touch engine logic.

1)Node ---> Mesh ---> Primitive(indexId, VertexId, MaterialId)

# Animation Will be a bigger pain in ECS

Animation system also need changes to map to ecs

nodeIndex will map to EntityId

I come to a solution of storing a mapping from old node index to entityId per instance of model in engine.
The animation data will be only one copy maybe in a animation manager and use id to get it,only state of animation will be stored per root entity.

#Shader code 
My system does not support the uint64 bit extension which is needed for using 
bindless textures in opengl.Instead i have used uvec2 to store 64 bit texture handles 
and retrive it but there is a case of endianness that i might need to look into later.



# Naming Probelms

I need to come up with a better name for VEC2 , VEC3 , VEC4 ,MAT4 to group under.
Currently i use ComponentType,
The word component does not feel right as it does not capture the meaning well enough.its a unit of data used in vertex attributes.
The meaning of component changs based on context.


# During developement i have noticed that
even to do vertex pulling with ssbo we need to bind a VAO even a dummy one for it to work.

# DESIGN PROBLEM IN ECS RENDERING SYSTEM INTERACTION

Another thing is that due to our lazy buffer creation when 
only data is uploaded if we try to render something without uplaoding 
data first it will cause to throw a error , 
THIS IS MORE OF A DESIGN PROBLEM IN RENDERING SYSTEM DRAW CALL CREATION SYSTEM WHERE WE GET DATA
FOR RENDERING FROM ECS,LIKE WE HAVE CURRENTLY NO WAY TO KNOW WHICH IS
ACTIVE IN SCENE,THE ECS JSUT GIVES ALL ENTITIES WITH REQUESTED COMPONENTS.

The problem arises when we just create a ui element and not upload
data to it and keep it for later use and when rendering system goes to 
render it will try to render this entity also.



# WARNING : Coordinate System Mix Up In UI Rendering

In our UI system the y is down and we do this by flipping Y Axis in camera parameters,
but this casues the winding order of generated geometries for UIs to 
change cause the geometries are generated by assuming Y up.
But since we flipped the Y in camera matrix and when we use the projection matrix in
shader it causes the winding order to become CW from CCW.
So for now disabling culling is a temp fix.

Also in in performance monitor system we have used a hack where we negate the height when we generate 
rectangles as the GeometryGenerators are in Y up coordinate system but our UI system is in Y down.


# 	Usage of glFinish() in world renderer.cpp
NOTE : This is a PERFORMANCE KILLER
	We are using glFinish() before rendering as to avoid a  synchronisation 
	issue where a old frame might not be done with the buffer when we write new data for new frame
	in the per object buffer we use to send modal matrix and material id,
	The issue is caused by us not using multiple buffers to avoid this kind of issue.
	But i am intentionally temporarily using this while i solidy the designs.



# Animation System Design Note :

We need to keep bone data in a cpu side manager
which also manages a gpu buffer for all bone data with a id system the 
root and all suscequent  meshs recieve this id.



# Adding IndexType also to VertexFormat

If we add IndexType To also vertexformat we can make the
draw calls etc also easy and we wont need to store each index type drawcalls separately